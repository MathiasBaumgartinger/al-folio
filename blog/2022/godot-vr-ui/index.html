<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Pretend a Mouse: VR-GUI in Godot | Mathias Baumgartinger-Seiringer </title> <meta name="author" content="Mathias Baumgartinger-Seiringer"> <meta name="description" content="How I cheated my way to VR-friendly UI in Godot by raycasting into a mesh, projecting into a viewport -- and then faking mouse events."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="MathiasBaumgartinger.github.io/blog/2022/godot-vr-ui/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.callout{background:#f6f8fa;border-left:4px solid #2962ff;padding:.8rem 1rem;border-radius:6px;margin:1rem 0}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Pretend a Mouse: VR-GUI in Godot",
            "description": "How I cheated my way to VR-friendly UI in Godot by raycasting into a mesh, projecting into a viewport -- and then faking mouse events.",
            "published": "February 05, 2022",
            "authors": [
              
              {
                "author": "Mathias Baumgartinger",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "Vienna, AT",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="glassy-box navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Mathias</span> Baumgartinger-S. </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse p-3 p-sm-0 glassy-box-navbar text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Dissemination </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i> </span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Pretend a Mouse: VR-GUI in Godot</h1> <p>How I cheated my way to VR-friendly UI in Godot by raycasting into a mesh, projecting into a viewport -- and then faking mouse events.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#tl-dr">TL;DR</a> </div> <div> <a href="#the-2d-vs-3d-ui-problem">The 2D vs. 3D UI Problem</a> </div> <div> <a href="#overview-of-the-setup">Overview of the Setup</a> </div> <div> <a href="#viewporttomesh-putting-ui-into-the-world">ViewportToMesh -- putting UI into the world</a> </div> <div> <a href="#ray-based-interaction-the-vr-laser-pointer">Ray-based Interaction -- the VR laser pointer</a> </div> <div> <a href="#finger-based-interaction-poking-buttons">Finger-based Interaction -- poking buttons</a> </div> <div> <a href="#faking-mouse-events">Faking Mouse Events</a> </div> <div> <a href="#edge-cases-trade-offs-and-thoughts">Edge Cases, Trade-offs and Thoughts</a> </div> </nav> </d-contents> <h2 id="tldr">TL;DR</h2> <p>For the Godot VR Toolkit I wanted <strong>proper GUI interaction in VR</strong> without rewriting or reinventing the wheel. So, I kept using <strong>normal Godot <code class="language-plaintext highlighter-rouge">Control</code> nodes</strong> and made them think they were being used with a mouse:</p> <ul> <li>A <code class="language-plaintext highlighter-rouge">Viewport</code> hosts a regular 2D UI.</li> <li> <code class="language-plaintext highlighter-rouge">ViewportToMesh.gd</code> renders that viewport onto a 3D mesh in the world.</li> <li> <code class="language-plaintext highlighter-rouge">GuiInteraction.gd</code> casts rays from VR controllers into that mesh.</li> <li> <code class="language-plaintext highlighter-rouge">GuiFinger.gd</code> tracks a finger tip collider for “poking” the UI.</li> <li>Both systems compute 2D coordinates inside the viewport and then <strong>synthesize <code class="language-plaintext highlighter-rouge">InputEventMouseMotion</code> / <code class="language-plaintext highlighter-rouge">InputEventMouseButton</code></strong> so the UI believes a mouse is moving and clicking.</li> </ul> <p>Result: 3D VR hands, laser pointer, hovering, clicking, dragging – but under the hood it’s still just <strong>mouse events and a viewport</strong>.</p> <p>The implementation can be found on <a href="https://github.com/boku-ilen/godot-vr-toolkit/blob/master/addons/vr-toolkit/Gui/" rel="external nofollow noopener" target="_blank">Github</a>.</p> <hr> <h2 id="the-2d-vs-3d-ui-problem">The 2D vs. 3D UI Problem</h2> <p>Godot is fundamentally stable and user-friendly at 2D GUIs: <code class="language-plaintext highlighter-rouge">Control</code> hierarchies, themes, focus handling, signals – all the usual desktop UI goodies.</p> <p>VR, on the other hand, lives entirely in 3D: controllers/hand meshes, raycasts, spatial interactions and depth perception. What you <em>don’t</em> have is a mouse pointer.</p> <p>Traditionally, user interface interactions in VR are handled by casting a ray from the controller (like a “laser pointer”) or by directly pinching, hence touching objects with a virtual hand/finger. Naively, you could:</p> <ol> <li>Implement a new VR-specific widget set (buttons, sliders, etc.),</li> <li>Or try to hack <code class="language-plaintext highlighter-rouge">Control</code>s to understand “rays” and “fingers”.</li> </ol> <p>Both approaches quickly turn into a rabbit hole of <strong>“oh right, I also need hover, drag, scroll, focus, keyboard…“</strong>.</p> <p>So instead I went for a “cheaper” trick that reuses Godot’s existing 2D GUI system as much as possible;:</p> <blockquote> <p>What if we keep the entire 2D GUI stack as-is and just pretend we’re a mouse?</p> </blockquote> <p>That leads to a very simple mental model:</p> <ul> <li>From VR’s perspective: <em>“I cast a ray / move a finger to a panel.”</em> </li> <li>From the UI’s perspective: <em>“The mouse moved to <code class="language-plaintext highlighter-rouge">(x, y)</code> and clicked.”</em> </li> </ul> <p>Everything in between is just coordinate transformations and synthetic input events.</p> <hr> <h2 id="overview-of-the-setup">Overview of the Setup</h2> <p>The three main scripts in play are:</p> <ul> <li> <p><a href="https://github.com/boku-ilen/godot-vr-toolkit/blob/master/addons/vr-toolkit/Gui/ViewportToMesh.gd" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">ViewportToMesh.gd</code></a><br> Renders a 2D <code class="language-plaintext highlighter-rouge">Viewport</code> (with <code class="language-plaintext highlighter-rouge">Control</code>s) onto a 3D mesh, including UV coordinate handling.</p> </li> <li> <p><a href="https://github.com/boku-ilen/godot-vr-toolkit/blob/master/addons/vr-toolkit/Gui/GuiInteraction.gd" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">GuiInteraction.gd</code></a><br> Handles ray-based interaction: a “laser pointer” from the controller that hits the GUI mesh.</p> </li> <li> <p><a href="https://github.com/boku-ilen/godot-vr-toolkit/blob/master/addons/vr-toolkit/Gui/GuiFinger.gd" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">GuiFinger.gd</code></a><br> Handles fingertip interaction: a collider on the tip of a VR hand that can “press” UI buttons directly.</p> </li> </ul> <p>In a slightly simplified picture:</p> <pre><code class="language-mermaid">flowchart LR
  H[VR Hand / Controller]
  H --&gt; R[Raycast]
  H --&gt; G[Finger Collider]
  R --&gt;|collide| M[GUI Mesh]
  G --&gt;|collide| M[GUI Mesh]
  M --&gt;|interpret collision point| M
  M --&gt;|pass faked mousevent| C[Viewport]
  C --&gt; E[Godot GUI system]
</code></pre> <p>The resulting faked mouse events are then processed by Godot’s normal GUI system, triggering hover states, button presses, etc..</p> <h2 id="viewporttomesh---putting-ui-into-the-world">ViewportToMesh - putting UI into the world</h2> <p>The starting point is trivial – rendering a UI to a texture and show it on a mesh:</p> <ul> <li>Inside that viewport lives a normal 2D UI: <ul> <li>Buttons, sliders, checkboxes, etc.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">ViewportToMesh</code>: <ul> <li>has a <code class="language-plaintext highlighter-rouge">SpatialMaterial</code> that takes a viewport texture (<code class="language-plaintext highlighter-rouge">Albedo</code> -&gt; <code class="language-plaintext highlighter-rouge">Texture</code> -&gt; <code class="language-plaintext highlighter-rouge">New ViewportTexture</code>)</li> <li>an export variable (<code class="language-plaintext highlighter-rouge">PackedScene</code>) to assign the <code class="language-plaintext highlighter-rouge">Viewport</code> node</li> <li>ensures UVs line up so that <code class="language-plaintext highlighter-rouge">(0,0)</code> in UV corresponds to <code class="language-plaintext highlighter-rouge">(0,0)</code> in the viewport, and <code class="language-plaintext highlighter-rouge">(1,1)</code> to <code class="language-plaintext highlighter-rouge">(width, height)</code> </li> <li>sets an <code class="language-plaintext highlighter-rouge">Area</code> and <code class="language-plaintext highlighter-rouge">CollisionShape</code> on the mesh to match the viewport size (e.g. a plane of size <code class="language-plaintext highlighter-rouge">width x height</code>) for querying collisions</li> </ul> </li> </ul> <p>As a node-hierarchy this might look like:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Spatial (World)
    ├── ViewportToMesh (MeshInstance)
    │    ├── Area
    │    │    └── CollisionShape
    │    └── Viewport (instanced PackedScene)
    ...
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vr-toolkit/ViewportToMesh-480.webp 480w,/assets/img/vr-toolkit/ViewportToMesh-800.webp 800w,/assets/img/vr-toolkit/ViewportToMesh-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/vr-toolkit/ViewportToMesh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Conceptually, when a ray hits the mesh, we get:</p> <ol> <li>The hit position in local coordinates</li> <li>The UV coordinate of that point on the mesh</li> <li>The corresponding pixel in the viewport</li> </ol> <h2 id="ray-based-interaction--the-vr-laser-pointer">Ray-based Interaction – the VR laser pointer</h2> <p>The ray-based interaction lives in <code class="language-plaintext highlighter-rouge">GuiInteraction.gd</code>; a ray originates from the VR controller (or camera), which – every frame – it casts into the world. This gives a classic <strong>laser-pointer style UI</strong>:</p> <ul> <li>visual line from controller to panel.</li> <li>cursor on the panel (optionally drawn in the viewport).</li> <li>trigger button maps to “left mouse button”.</li> </ul> <p>The interesting bit is not the raycast itself (that’s standard Godot), but what happens in <code class="language-plaintext highlighter-rouge">_send_mouse_motion</code> and <code class="language-plaintext highlighter-rouge">_send_mouse_button</code> – that’s where we fake mouse events.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vr-toolkit/RayInteract-480.webp 480w,/assets/img/vr-toolkit/RayInteract-800.webp 800w,/assets/img/vr-toolkit/RayInteract-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/vr-toolkit/RayInteract.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="finger-based-interaction--poking-buttons">Finger-based Interaction – poking buttons</h2> <p><code class="language-plaintext highlighter-rouge">GuiFinger.gd</code> is the second interaction mode: <strong>direct hand interaction</strong>.</p> <p>Instead of a laser pointer, we have:</p> <ul> <li>A VR hand skeleton or mesh.</li> <li>A collider on the fingertip (e.g. index finger).</li> <li>The finger collider collides with the GUI mesh.</li> </ul> <p>The flow is essentially:</p> <ol> <li>The finger collider overlaps with the GUI mesh or a dedicated interaction volume.</li> <li>From the collision, we again get: <ul> <li>Contact point on the mesh,</li> <li>UV coordinate at that point.</li> </ul> </li> <li>From UV we compute viewport coordinates.</li> <li>From those coordinates we synthesize: <ul> <li>Hover events while finger is near the surface,</li> <li>A “click” when the finger crosses some threshold (e.g. penetration depth / velocity / pinch gesture).</li> </ul> </li> </ol> <p>Where the ray pointer feels a bit like a laser pointer/remote, <strong>finger interaction feels like actually poking the UI</strong> – but internally, both boil down to the same <code class="language-plaintext highlighter-rouge">InputEventMouse</code>-machinery.</p> <h2 id="faking-mouse-events">Faking Mouse Events</h2> <p>Now the fun part: <strong>lying to Godot’s GUI</strong>.</p> <p>The goal: from the GUI’s perspective, nothing special is happening. It just sees mouse movement and clicks.</p> <h3 id="1-function-overview">1. Function overview</h3> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="nf">ray_interaction_input</span><span class="p">(</span><span class="n">position3D</span><span class="p">:</span> <span class="kt">Vector3</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">pressed</span><span class="o">=</span><span class="kt">null</span><span class="p">):</span>
</code></pre></div></div> <p>This function turns a <strong>3D hit position on the GUI mesh</strong> into a <strong>2D mouse-like input event</strong> for a viewport.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">position3D</code>: where the ray (or fingertip) hit the GUI in world space.</li> <li> <code class="language-plaintext highlighter-rouge">event_type</code>: which kind of mouse event to create (<code class="language-plaintext highlighter-rouge">InputEventMouseMotion</code> or <code class="language-plaintext highlighter-rouge">InputEventMouseButton</code>).</li> <li> <code class="language-plaintext highlighter-rouge">device_id</code>: which input device (controller) this event belongs to.</li> <li> <code class="language-plaintext highlighter-rouge">pressed</code>: only relevant for button events, indicates down/up.</li> </ul> <p>The rest of the function:</p> <ol> <li>Converts coordinates into viewport space.</li> <li>Builds the appropriate mouse event.</li> <li>Sends it into the viewport so regular Godot <code class="language-plaintext highlighter-rouge">Control</code> nodes react to it.</li> </ol> <h3 id="2-world---local---2d-panel-coordinates">2. World -&gt; local -&gt; 2D panel coordinates</h3> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">position3D</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">global_transform</span><span class="o">.</span><span class="n">affine_inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">position3D</span>
	<span class="k">var</span> <span class="n">position2D</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="n">position3D</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position3D</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">area.global_transform.affine_inverse()</code> converts the world-space hit position into the <strong>local space of <code class="language-plaintext highlighter-rouge">area</code></strong> (the GUI panel / collision area).</li> <li>Because the panel is rotated by 90°, its surface is aligned in the <strong>X–Z plane</strong>.</li> <li>So we keep only <code class="language-plaintext highlighter-rouge">(x, z)</code> and throw away the third dimension, ending up with a <strong>2D point on the panel</strong>: <code class="language-plaintext highlighter-rouge">position2D</code>.</li> </ul> <p>At this point, <code class="language-plaintext highlighter-rouge">position2D</code> still uses the panel’s own local units, centered on its origin.</p> <h3 id="3-local-panel-coordinates---normalized-uv---viewport-pixels">3. Local panel coordinates -&gt; normalized UV -&gt; viewport pixels</h3> <h4 id="centered-local-range---0-based-quad-range">Centered local range -&gt; 0-based quad range</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">position2D</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">quad_mesh_size</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="n">position2D</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">quad_mesh_size</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div> <ul> <li>The quad is centered at <code class="language-plaintext highlighter-rouge">(0, 0)</code> with extents <code class="language-plaintext highlighter-rouge">±quad_mesh_size/2</code>.</li> <li>By adding half the size, we shift the coordinate system so it runs from <strong>0 to <code class="language-plaintext highlighter-rouge">quad_mesh_size</code></strong> in both directions.</li> <li>Now <code class="language-plaintext highlighter-rouge">(0, 0)</code> is one corner of the quad and <code class="language-plaintext highlighter-rouge">(quad_mesh_size.x, quad_mesh_size.y)</code> is the opposite corner.</li> </ul> <h4 id="quad-range---normalized-01">Quad range -&gt; normalized 0..1</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">position2D</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position2D</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">quad_mesh_size</span><span class="o">.</span><span class="n">x</span>
	<span class="n">position2D</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position2D</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">quad_mesh_size</span><span class="o">.</span><span class="n">y</span>
</code></pre></div></div> <ul> <li>Dividing by the mesh size converts the coordinates into <strong>normalized UV space</strong>: <ul> <li> <code class="language-plaintext highlighter-rouge">0.0</code> -&gt; start of the axis,</li> <li> <code class="language-plaintext highlighter-rouge">1.0</code> -&gt; end of the axis.</li> </ul> </li> </ul> <p>So <code class="language-plaintext highlighter-rouge">position2D</code> is now in the range <code class="language-plaintext highlighter-rouge">(0..1, 0..1)</code> and basically matches the UVs of the quad.</p> <h4 id="normalized-uv---viewport-pixel-coordinates">Normalized UV -&gt; viewport pixel coordinates</h4> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">position2D</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position2D</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">viewport</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">x</span>
	<span class="n">position2D</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position2D</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">viewport</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">y</span>
</code></pre></div></div> <ul> <li>Multiplying the normalized values by the viewport size maps them to <strong>actual pixel positions</strong> inside the viewport.</li> <li>Now: <ul> <li> <code class="language-plaintext highlighter-rouge">(0, 0)</code> is the top-left corner of the viewport.</li> <li> <code class="language-plaintext highlighter-rouge">(viewport.size.x, viewport.size.y)</code> is the bottom-right.</li> </ul> </li> </ul> <p>This is exactly the coordinate system Godot’s GUI expects for mouse events.</p> <hr> <h2 id="4-creating-and-configuring-the-mouse-event">4. Creating and configuring the mouse event</h2> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">event</span> <span class="o">=</span> <span class="n">event_type</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
</code></pre></div></div> <p>Here we instantiate whichever mouse event type was passed in (<code class="language-plaintext highlighter-rouge">InputEventMouseMotion</code> or <code class="language-plaintext highlighter-rouge">InputEventMouseButton</code>).</p> <h3 id="mouse-motion">Mouse motion</h3> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="n">event</span> <span class="k">is</span> <span class="n">InputEventMouseMotion</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">last_pos2D</span> <span class="o">==</span> <span class="kt">null</span><span class="p">:</span>
			<span class="n">event</span><span class="o">.</span><span class="n">relative</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">event</span><span class="o">.</span><span class="n">relative</span> <span class="o">=</span> <span class="n">position2D</span> <span class="o">-</span> <span class="n">last_pos2D</span>
</code></pre></div></div> <ul> <li>For <strong>motion events</strong>, besides the absolute position we also fill <code class="language-plaintext highlighter-rouge">relative</code>: <ul> <li>If this is the first event, there is no previous position -&gt; relative movement is <code class="language-plaintext highlighter-rouge">(0, 0)</code>.</li> <li>Otherwise we subtract <code class="language-plaintext highlighter-rouge">last_pos2D</code> from the new position for a <strong>movement delta</strong>.</li> </ul> </li> <li>This delta can be used internally by Godot or custom logic to know how far the pointer moved.</li> </ul> <h3 id="mouse-button">Mouse button</h3> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">elif</span> <span class="n">event</span> <span class="k">is</span> <span class="n">InputEventMouseButton</span><span class="p">:</span>
		<span class="n">event</span><span class="o">.</span><span class="n">button_index</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="n">event</span><span class="o">.</span><span class="n">pressed</span> <span class="o">=</span> <span class="n">pressed</span>
</code></pre></div></div> <ul> <li>For <strong>button events</strong>, we set: <ul> <li> <code class="language-plaintext highlighter-rouge">button_index = 1</code> -&gt; left mouse button.</li> <li> <code class="language-plaintext highlighter-rouge">pressed</code> -&gt; uses the argument passed into the function to differentiate between button-down and button-up.</li> </ul> </li> </ul> <hr> <h2 id="5-final-bookkeeping-and-sending-the-event">5. Final bookkeeping and sending the event</h2> <div class="language-gdscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">last_pos2D</span> <span class="o">=</span> <span class="n">position2D</span>
	<span class="n">event</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position2D</span>
	<span class="n">event</span><span class="o">.</span><span class="n">global_position</span> <span class="o">=</span> <span class="n">position2D</span>

	<span class="n">event</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device_id</span>
	<span class="n">viewport</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">last_pos2D</code> is updated so the next motion event can compute a correct <code class="language-plaintext highlighter-rouge">relative</code> delta.</li> <li> <code class="language-plaintext highlighter-rouge">event.position</code> and <code class="language-plaintext highlighter-rouge">event.global_position</code> are both set to the computed viewport coordinates (for GUI, these are typically the same).</li> <li> <code class="language-plaintext highlighter-rouge">event.device</code> identifies which controller generated this event.</li> <li>Finally, <code class="language-plaintext highlighter-rouge">viewport.input(event)</code> injects the event into the viewport’s input pipeline.</li> </ul> <p>From this point on, Godot treats it like a <strong>normal mouse event</strong>:</p> <ul> <li>Buttons, sliders, and other <code class="language-plaintext highlighter-rouge">Control</code> nodes react to hover and clicks.</li> <li>No special VR logic is needed in the UI layer – everything is handled via synthetic mouse events.</li> </ul> <p>The nice part is that <strong>dragging a slider</strong> via a VR ray is literally the same code path as dragging it with a real mouse.</p> <h2 id="edge-cases-trade-offs-and-thoughts">Edge Cases, Trade-offs and Thoughts</h2> <p>This approach works surprisingly well, but it’s not magic. A few gotchas and design decisions:</p> <h3 id="1-coordinate-precision--panel-curvature">1. Coordinate precision &amp; panel curvature</h3> <p>If you bend or distort your mesh (curved UI panels), you have to ensure:</p> <ul> <li>UVs are still meaningful,</li> <li>or you compute projection more explicitly (e.g. project onto plane, then transform).</li> </ul> <p><code class="language-plaintext highlighter-rouge">ViewportToMesh</code> acts as the contract: its job is to make sure <strong>“UV -&gt; viewport pixel”</strong> stays consistent.</p> <h3 id="2-focus-and-keyboard-input">2. Focus and keyboard input</h3> <p>Mouse is only half the story:</p> <ul> <li>Text input, keyboard focus, etc., still follow the usual Godot rules.</li> <li>Depending on your VR keyboard solution, you may want to: <ul> <li>Programmatically focus controls,</li> <li>Forward <code class="language-plaintext highlighter-rouge">InputEventKey</code> from a VR keyboard into the viewport.</li> </ul> </li> </ul> <p>The nice thing: you <strong>don’t</strong> have to change how <code class="language-plaintext highlighter-rouge">LineEdit</code> or <code class="language-plaintext highlighter-rouge">TextEdit</code> work, you just feed them events.</p> <h3 id="3-multiple-pointers--hands">3. Multiple pointers / hands</h3> <p>In VR you might have:</p> <ul> <li>Left-hand ray,</li> <li>Right-hand ray,</li> <li>Fingers on both hands.</li> </ul> <p>The mouse model assumes a single pointer. In practice, I make a conscious decision:</p> <ul> <li>Only one “active” pointer at a time.</li> <li>Usually taken from “last device that interacted” or a prioritized order (e.g. right-hand ray &gt; finger &gt; left-hand ray).</li> </ul> <p>For more complex setups you could emulate multiple mice by tagging events, but that quickly diverges from Godot’s standard assumptions.</p> <h3 id="4-when-not-to-fake-mouse-events">4. When <em>not</em> to fake mouse events</h3> <p>Not every VR interaction needs to pretend to be a mouse:</p> <ul> <li>Grabbing objects, teleportation, gunplay, etc. are better done via custom input handling.</li> <li>The “fake mouse” approach shines specifically when you want: <ul> <li>Menus,</li> <li>Settings panels,</li> <li>HUDs,</li> <li>Anything that logically <strong>is</strong> a 2D UI, just spatially placed.</li> </ul> </li> </ul> <h2 id="closing-thoughts">Closing Thoughts</h2> <blockquote> <p><strong>Start from the existing machinery, then adapt the edges.</strong></p> </blockquote> <p>By bending the inputs to look like mouse events, I can:</p> <ul> <li>Reuse all of that,</li> <li>Keep VR interaction code relatively small,</li> <li>Avoid building a bespoke VR widget library.</li> </ul> <p>The triad of <code class="language-plaintext highlighter-rouge">ViewportToMesh.gd</code>, <code class="language-plaintext highlighter-rouge">GuiInteraction.gd</code>, and <code class="language-plaintext highlighter-rouge">GuiFinger.gd</code> is essentially just:</p> <ul> <li>A 3D wrapper around a 2D viewport,</li> <li>Coordinate plumbing,</li> <li>And a thin layer of <strong>input forgery</strong>.</li> </ul> <p>From the user’s perspective it feels like <strong>“of course I can point at that button and press it”</strong>.<br> From Godot’s perspective, they just moved a mouse and clicked.</p> <p>And that’s exactly the kind of cheating I enjoy.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://wimby.eu/engaging-the-local-community-wimby-workshops-in-styria/" target="_blank" rel="external nofollow noopener">Engaging the local community: WIMBY workshops in Styria</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://biopv.boku.ac.at/post/25-04-22-workshops-lungau-unteres-murtal/" target="_blank" rel="external nofollow noopener">Start der BioPV-Labs: Gemeinsam die Zukunft gestalten! | BioPV</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/knox+refresh/">Extending Django Knox by secure refresh-tokens</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/istanbul/">Istanbul -- the bridge between Europe and Asia</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/catenary/">Catenary objects: putting a wire between two points (in 3D)</a> </li> <br> <br> <div id="giscus_thread"> <script defer src="/assets/js/giscus-setup.js"></script> <noscript> Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </d-article> </div> <div class="full-width"></div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Mathias Baumgartinger-Seiringer. Last updated: November 18, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>